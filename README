(h)igher (o)rder (t)ype(s) for haxe

Haxe lacks type constructor polymorphism, which is essential for the implementation of High Order Types.
To circumvent this missing piece we introduce two special abstract types "Of" and "In". "Of" is a type constructor which takes two types, the wrapper type and the inner type.
The abstract haskell type "f a" translates to the haxe type "Of<F,A>". A type class is represented by an interface and a corresponding abstract class which implements default implementations. Every type class has an abstract base class, even if there is no implementation (this may change in further revisions).

Functor translation example: haskell -> haxe

class Functor f where
   fmap :: (a -> b) -> f a -> f b

 
interface Functor<F> implements hots.TC {
	pulic function map <A,B> (A->B, f:Of<F,A>):Of<F,B>;
}

@:tcAbstract class FunctorAbstract<F> implements Functor<F>
{
  public function map<A,B>(f:A->B, val:Of<F,A>):Of<F,B> return Scuts.abstractMethod()
}

Another important feature of type classes are constraints for type parameters. This is achieved by interface inheritance and delegation inside of the abstract class.

The class Applicative in haxe for example has the constraint that the wrapped inner type must be a Functor instance:

interface Applicative<M> implements Functor<M>, implements TC
{
  public function ret<A>(x:A):Of<M,A>;

  public function apply<A,B>(f:Of<M,A->B>, val:Of<M,B>):Of<M,B>;
  
  public function thenRight<A,B>(val1:Of<M,A>, val2:Of<M,B>):Of<M,B>;
  
  public function thenLeft<A,B>(val1:Of<M,A>, val2:Of<M,B>):Of<M,A>;
}

@:tcAbstract class ApplicativeAbstract<M> implements Applicative<M>
{
  // constraint
  var functor:Functor<M>;
  
  // constraint delegation
  @:final public inline function map<A,B>(f:A->B, val:Of<M,A>):Of<M,B> return functor.map(f, val)
  
  function new (functor:Functor<M>) { this.functor = functor; }
  
  // functions 
  public function ret<A>(x:A):Of<M,A> return Scuts.abstractMethod()
  public function apply<A,B>(f:Of<M,A->B>, val:Of<M,B>):Of<M,B> return Scuts.abstractMethod()
  public function thenRight<A,B>(val1:Of<M,A>, val2:Of<M,B>):Of<M,B> return val2
  public function thenLeft<A,B>(val1:Of<M,A>, val2:Of<M,B>):Of<M,A> return val1
}